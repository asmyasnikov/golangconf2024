# Как в Go жить без перегрузок и значений аргументов по умолчанию?

## План доклада

1. [1 минута] Вводное слово
2. [1 минута] Есть приятные вещи в других ЯП, которых нет в Go - например, перегрузка функций и дефолтные значения аргументов функций
3. [1 минута] Теория что такое перегрузка функций и для чего она нужна
4. [10 минут] Практическая задач - объявить тип, имеющий состояние, который должен выполнять какую-либо фоновую работу. Например, драйвер базы данных. Тут рассмотрим варианты (с примерами из реальных проектов), их плюсы и минусы.
  * Публичный тип с публичными полями. Инициализация полей ложится на пользователя типа. Тут огромное пространство для багов.
  * Публичный тип с приватными полями. Публичный `Init()`, который обязует программиста дернуть его перед началом использования экземпляра типа. Возможный баг, выясняемый в runtime - объект НЕ инициализирован. Другой баг - пользватель объявит `var db somepkg.Driver` и нигде его не инициализирует.
  * Публичный тип с приватными полями. Приватный `init()` и необходимость на каждом вызове публичном методе типа проверять состояние (инициализировано или нет) и дергать init(). Пользователь не имеет риска набажить, кроме возможности простого объявления `var db somepkg.Driver`. Зато разработчик типа может набажить, забыв дернуть `init()`, или дернув его дважды.
  * Публичный тип + конструктор типа. Возможен баг с простым объявлением `var db somepkg.Driver`. Но конструктор типа уже позволяет создать объект в правильном состоянии.
  * Приватный тип + конструктор типа. У пользователя нет возможности объявить `var db somepkg.driver`, но есть возможность создать экземпляр типа в правильном состоянии и сохранить его через `:=`

  Краткое итого: удобные типы иногда небезопасны для использования. В погоне за менее бажным кодом использования удобство ухудшается, а надежность пользовательского кода повышается

5. [10 минут] Переходим к конструкторам. Практическая задача - сконструировать тип, используя разумные дефолты для полей, но надо дать возможность переопределить некоторые дефолты. Тут рассмотрим варианты (с примерами реальных проектов):
  * Конструктор с явным набором аргументов `New(a int, b string, c float, d bool)`. Нельзя задать дефолты, невозможно поддерживать, не ломая обратную совместимость
  * Конструтор с одним аргументом - настройками `New(settings struct{ a int, b string, c float, d bool})`. Расширяемо в будущем (но невозможно "закопать" устаревшие поля в настройках). Нельзя задать дефолты. Невозможно отличить явный 0 от default type value.
  * Конструктор с обязательными аргументами и функциональными опциями `New(requiredA int, requiredB string, opts ...func(*myType))`. Расширяемо. Закапывание устаревшего через `noop`. Внутри `New` можно задать дефолты. Когда опций много в namespace пакета - это пользователя тратить время на поиск/выбор нужной опции. Если в пакете несколько конструторов разных типов, то сложно отличить опции конструктора одного типа от опций конструктора другого типа.
  * Конструктор с обязательными аргументами и опциями-интерфейсами `New(requiredA int, requiredB string, opts interface{applyMyTypeOption(*myType)})`. Все плюсы предыдущего подхода. Одинаковые по смыслу и имени опции могут подходить для нескольких конструкторов.
  * Конструктор-билдер `New(requiredA int, requiredB string).WithC(c).WithD(d)`. Расширяемо. Закапывание устаревшего через `noop`. Внутри `New` можно задать дефолты. Нет проблемы с кучей публичных методов - опций как в предыдущем подходе. Остается вопрос полемики - должны ли опции `With*` менять состояние исходного объекта или порождать измененную копию этого объекта?
  * Конструктор-билдер `New(requiredA int, requiredB string).WithC(c).WithD(d).Build()`. Расширяемо. Закапывание устаревшего через `noop`. Внутри `New` можно задать дефолты. Явный `Build` в конце конструирует объект в нужном состоянии (в т.ч. запускает фоновые процессы). Безопасно, понятно, IDE driven development помогает здесь (в частности auto-complete).

[3 минуты] В конце раздела думаю все подходы следует свести в табличку с плюсами и минусами, а также привести результаты бенчей.

6. [1 минута] От конструкторов переходим просто к функциям и их "перегрузкам". Практическая задача - (не придумал еще, не нашел достойного примера)

6.1. [1 минут] Рекомендованный подход в ЯП без перегрузок - писать разные имена функций. Тут N примеров надо, чтобы стало понятно, что это неудобно.

6.2. [2 минуты] Единое имя функции для плюс-минус одинаковой логики возможно в Go за счет:
   * функциональных опций
   * опций-интерфейсов
   * context (футакделать)

7. [3 минуты] Выводы-рекомендации:
* когда какие варианты следует использовать. Отдельный акцент на OpenSource, SemVer и поломках обратной совместимости. Не все подходы позволяют максимально долго НЕ ломать обратную совместимость
* про баланс удобство-надежность
* про производительность

Финалочка: в Go возможно жить без перегрузок функций и дефолтных значений аргументов, но подходы нельзя назвать "из коробки".

=======================================================================================================

### Вводное слово 

кто я - много практики, живу в OpenSource, много разбираю багов, возникающих при работе с моим же кодом, много думаю про то, как не дать людям написать баг. 

зачем хотеть перегрузки функций и значения аргументов по умолчанию? Тут нытье про то, что в других ЯП есть такое, а в Go нет

### Чуть-чуть теории (вики, словари) про понятия

Перегрузка функций нужна для следующих целей:

* Избежание дублирования имён функций. Если нужно выполнить сходные действия, но с различной программной логикой, можно определить несколько функций с одинаковым именем, но различными параметрами. [1](http://cppstudio.com/post/406/)
* Предоставление различной семантики для функции. [5](https://www.geeksforgeeks.org/function-overloading-c/) В зависимости от сигнатуры функций (списка параметров) перегруженные функции могут по-разному выполняться и возвращать значения разных типов. [3](https://purecodecpp.com/archives/1391)
* Повышение читаемости программы. Если нужно выполнить только одну операцию, и у функций одинаковое название, это упрощает понимание поведения программы. Например, если нужно сложить заданные числа, но аргументов может быть любое количество. [5](https://www.geeksforgeeks.org/function-overloading-c/)
* Перегрузка функций — это возможность в языках программирования использовать одноимённые подпрограммы с разным числом аргументов или их типами. [4](https://ru.ruwiki.ru/wiki/Перегрузка_процедур_и_функций)

### Практическая задача

Описать сложный тип, имеющий состояние, и предложить пути его использования. Например, драйвер базы данных (позже может перепридумаю пример)

#### Пути решения

Решая каждый раз одну и ту же задачу разными подходами - оцениваем плюсы и минусы подхода

##### Публичный тип с публичными полями. 

```go
type Driver struct {
  Connection *grpc.ClientConn
  Timeout time.Duration
  Mutex sync.Mutex
  CallCounter uint64
}
```

Плюсы:
1) Легко объявлять и использовать в своем коде 
   ```go
   db := &Driver{
     Connection: conn,
     Timeout: time.Second,
     Mutex: sync.Mutex{},
     CallCounter: 0,
   }
   ```
2) Прозрачность

Минусы:
1) Легко накосячить с значениями полей
2) Не позволяет автоматически стартовать фоновые процессы

##### Публичный тип с приватным init()

Пример - sync.Pool, container/list.List

Плюсы:
- по прежнему удобно создавать переменную типа

Минусы:
- на каждом вызове публичного метода следует проверять в каком состоянии объект и вызывать init()

##### Публичный тип с приватными полями + публичный конструктор типа

Пример - database/sql.DB

##### Публичный тип с приватными полями + публичный конструктор типа

В конце хочу бенчи всех подходов и сводную табличку
